<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode</title>
      <link href="/2020/08/09/hello-world/"/>
      <url>/2020/08/09/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). --><h1 id="Leetcode算法解答"><a href="#Leetcode算法解答" class="headerlink" title="Leetcode算法解答."></a>Leetcode算法解答.</h1><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114.<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/"> 二叉树展开为链表</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(root == nullptr) return;</span></span><br><span class="line">        <span class="keyword">int</span> white = <span class="number">0</span>, gray = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,TreeNode*&gt;&gt;<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(white,root));</span><br><span class="line">        TreeNode* dummyroot = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> color = <span class="built_in">stack</span>.top().first;</span><br><span class="line">            TreeNode* node = <span class="built_in">stack</span>.top().second;</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(color == white)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(white,node-&gt;right));</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(white,node-&gt;left));</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(gray,node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dummyroot-&gt;right = node;</span><br><span class="line">                dummyroot-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                dummyroot = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = dummyroot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.<a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h2><p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。<br>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）<br>题目数据保证答案符合 32 位带符号整数范围。</p><p>输入：S = “rabbbit”, T = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 S 中得到 “rabbit” 的方案。<br>(上箭头符号 ^ 表示选取的字母)<br>rabbbit<br>^^^^ ^^<br>rabbbit<br>^^ ^^^^<br>rabbbit<br>^^^ ^^^<br>###DFS暴力解法超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        dfs(s,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span>&amp; t, <span class="keyword">int</span> count,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = count; i &lt; s.<span class="built_in">size</span>() &amp;&amp; i + t.<span class="built_in">size</span>() - index<span class="number">-1</span> &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != t[index]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// current.push_back(s[i]);</span></span><br><span class="line">            dfs(s,t,i+<span class="number">1</span>,index+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// current.pop_back();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]表示s的前i个字符中出现t前j个字符的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###动态规划减少空间复杂度<br>由于dp[i][j]只与前一行有关系,因此可以使用一维数组代替.,由于d[j-1]的值会被覆盖,因此从后往前,避免覆盖问题.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]表示s的前i个字符中出现t前j个字符的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                    dp[j] = dp[j<span class="number">-1</span>] + dp[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = dp[j];;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###动态规划减少空间复杂度<br>同时也可以在覆盖之前,保存该值.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j]表示s的前i个字符中出现t前j个字符的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> pre = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> cur = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                    dp[j] = pre + dp[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a>124.<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h2><p>给定一个非空二叉树，返回其最大路径和。<br>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br>采用先序遍历,创建新的结点依次链接先序遍历得到的值.<br>示例:[-10,9,20,null,null,15,7]<br><img src= "/img/loading.gif" data-lazy-src="/img/leetcode124.png"><br>输出:42</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> MAX = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(helper(root), MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_distance = <span class="built_in">max</span>(<span class="number">0</span>, helper(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right_distance = <span class="built_in">max</span>(<span class="number">0</span>, helper(root-&gt;right));</span><br><span class="line">        MAX = <span class="built_in">max</span>(MAX, root-&gt;val + left_distance + right_distance);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(left_distance, right_distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/img/leetcode124tujie.png"><br>子节点距离最大情况分为3种: 左分支: b-&gt;a, 右分支: c-&gt;a,取最大值返回给父节点.<br>或者是b-&gt;a-&gt;c,不需要父节点.取两者最大值为结果.<br>采用后序遍历, 子节点向父节点返回最大距离.</p><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127.单词接龙"></a>127.<a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙</a></h2><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:<br>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出: 5<br>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。</p><p>###深度优先遍历找到每个单词相差为1的单词作为下一次的可选项,直到单词等于结束的单词.<br>####第一版超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> MINlen;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit(wordList.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        MINlen = wordList.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        dfs(beginWord,endWord,wordList,visit,<span class="number">0</span>);</span><br><span class="line">        MINlen = MINlen == wordList.<span class="built_in">size</span>() + <span class="number">1</span>? <span class="number">0</span> : MINlen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> MINlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; beginWord, <span class="built_in">string</span>&amp; endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visit, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; MINlen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(beginWord == endWord)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &lt; MINlen)</span><br><span class="line">            &#123;</span><br><span class="line">                MINlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!onedifferent(beginWord, wordList[i])) <span class="keyword">continue</span>;</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(wordList[i], endWord, wordList, visit, len+<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">onedifferent</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i] != word2[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>####第二版,速度提升,但是超时<br><img src= "/img/loading.gif" data-lazy-src="/img/leetcode127tujie.png"><br>搜索每个单词相差一个的单词作为下一次的选项,并且,这次的单词和其待选选项在下层都不会被作为选项,因为不这样的话,选择的结果肯定不是最短路径.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> MINlen;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordset;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit(wordList.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : wordList) wordset.insert(str);</span><br><span class="line">        MINlen = wordList.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        dfs(beginWord,endWord,<span class="number">0</span>);</span><br><span class="line">        MINlen = MINlen == wordList.<span class="built_in">size</span>() + <span class="number">1</span>? <span class="number">0</span> : MINlen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> MINlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; beginWord, <span class="built_in">string</span>&amp; endWord, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; MINlen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(beginWord == endWord)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &lt; MINlen)</span><br><span class="line">            &#123;</span><br><span class="line">                MINlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordset_cur = wordset;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res = gexnext(beginWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(res[i], endWord, len+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wordset = wordset_cur;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">gexnext</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        wordset.erase(<span class="keyword">word</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">char</span> word_i = <span class="keyword">word</span>[i];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">word</span>[i] = c;</span><br><span class="line">                <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(<span class="keyword">word</span>) != wordset.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                   res.push_back(<span class="keyword">word</span>);</span><br><span class="line">                   wordset.erase(<span class="keyword">word</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">word</span>[i] = word_i;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>##广度优先遍历BFS(求最短路径,BFS更好用点)<br>###第一版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : wordList) wordset.insert(str);</span><br><span class="line">        <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(endWord) == wordset.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt;&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="built_in">queue</span>.push(<span class="built_in">make_pair</span>(beginWord,len));</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">queue</span>.<span class="built_in">size</span>();  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> <span class="keyword">word</span> = <span class="built_in">queue</span>.front().first;</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> word_i = <span class="keyword">word</span>[i];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">word</span>[i] = c;</span><br><span class="line">                        <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(<span class="keyword">word</span>) != wordset.<span class="built_in">end</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">word</span> == endWord)</span><br><span class="line">                                <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">                            <span class="built_in">queue</span>.push(<span class="built_in">make_pair</span>(<span class="keyword">word</span>,len+<span class="number">1</span>));</span><br><span class="line">                            wordset.erase(<span class="keyword">word</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">word</span>[i] = word_i;           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###第二版<br>队列不需要储存高度,外部计数深度就OK.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : wordList) wordset.insert(str);</span><br><span class="line">        <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(endWord) == wordset.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="built_in">queue</span>.push(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">queue</span>.<span class="built_in">size</span>();  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> <span class="keyword">word</span> = <span class="built_in">queue</span>.front();</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> word_i = <span class="keyword">word</span>[i];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">word</span>[i] = c;</span><br><span class="line">                        <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(<span class="keyword">word</span>) != wordset.<span class="built_in">end</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">word</span> == endWord)</span><br><span class="line">                                <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">                            <span class="built_in">queue</span>.push(<span class="keyword">word</span>);</span><br><span class="line">                            wordset.erase(<span class="keyword">word</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">word</span>[i] = word_i;           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###第三版 双向BFS,正向遍历标记为1,逆向遍历为2,当既被正向又被逆向遍历为3,输出结果.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; wordmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : wordList)</span><br><span class="line">            wordmap[str] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(wordmap.<span class="built_in">find</span>(endWord) == wordmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; frontqueue,backqueue;</span><br><span class="line">        frontqueue.push(beginWord);</span><br><span class="line">        backqueue.push(endWord);</span><br><span class="line">        wordmap[beginWord] |= <span class="number">1</span>; wordmap[endWord] |= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!frontqueue.empty() &amp;&amp; !backqueue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;nowqueue = frontqueue.<span class="built_in">size</span>() &gt; backqueue.<span class="built_in">size</span>()? backqueue: frontqueue;</span><br><span class="line">            <span class="keyword">int</span> visit_flag = frontqueue.<span class="built_in">size</span>() &lt;= backqueue.<span class="built_in">size</span>()? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> n = nowqueue.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> <span class="keyword">word</span> = nowqueue.front();</span><br><span class="line">                nowqueue.pop(); </span><br><span class="line">                <span class="comment">// 取引用有的示例会出错.取引用的话,将nowqueue.pop()最后执行,可以写成for(int i = 0; i &lt; n; i++,nowqueue.pop())</span></span><br><span class="line">                <span class="comment">// string&amp; word = nowqueue.front(); </span></span><br><span class="line">                <span class="comment">// nowqueue.pop(); </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> word_ori = <span class="keyword">word</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">                    &#123;  </span><br><span class="line">                        <span class="keyword">if</span>(c == word_ori[i]) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">word</span>[i] = c;</span><br><span class="line">                        <span class="keyword">if</span>(wordmap.<span class="built_in">find</span>(<span class="keyword">word</span>) != wordmap.<span class="built_in">end</span>() &amp;&amp; !(wordmap[<span class="keyword">word</span>]&amp;visit_flag))</span><br><span class="line">                        &#123;</span><br><span class="line">                           wordmap[<span class="keyword">word</span>] |= visit_flag;<span class="keyword">if</span>(wordmap[<span class="keyword">word</span>] == <span class="number">3</span>) <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">                           nowqueue.push(<span class="keyword">word</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">word</span> = word_ori;          </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126.单词接龙 II"></a>126.<a href="https://leetcode-cn.com/problems/word-ladder-ii/">单词接龙 II</a></h2><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换后得到的单词必须是字典中的单词。<br>说明:<br>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p><p>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]</p><p>看注释,和125思路几乎一致,主要差别在于,不是取一个元素,就在可选列表删除该元素,因为可能存在多个父节点有一个共同的子节点.所以在遍历完一层元素后再删除该层元素.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;current;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&gt;Graph = graph_bfs(beginWord, endWord, wordList);<span class="comment">//生成邻接图</span></span><br><span class="line">        current.push_back(beginWord);</span><br><span class="line">        dfs(Graph, beginWord, endWord);<span class="comment">//dfs遍历得到结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;string,unordered_set&lt;string&gt;&gt; graph_bfs(string&amp; beginWord, string&amp; endWord, vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&gt;graph;<span class="comment">//生成邻接图</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordset;<span class="comment">//当前可选元素</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; del;<span class="comment">//每行选择元素删除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : wordList) wordset.insert(str);</span><br><span class="line">        <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(endWord) == wordset.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="built_in">queue</span>.push(beginWord);</span><br><span class="line">        wordset.erase(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty() &amp;&amp; wordset.count(endWord) != <span class="number">0</span>)<span class="comment">//退出条件,是可选择元素里面没有endword</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//删除该行已经选择过的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> str : del)</span><br><span class="line">                wordset.erase(str);</span><br><span class="line">            del.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">queue</span>.<span class="built_in">size</span>();  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> <span class="keyword">word</span> = <span class="built_in">queue</span>.front();</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++)<span class="comment">//找到与父节点单词相差一个字符的字符串</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> newword = <span class="keyword">word</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(c == <span class="keyword">word</span>[i])  <span class="keyword">continue</span>;</span><br><span class="line">                        newword[i] = c;</span><br><span class="line">                        <span class="keyword">if</span>(wordset.<span class="built_in">find</span>(newword) != wordset.<span class="built_in">end</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            graph[<span class="keyword">word</span>].insert(newword);</span><br><span class="line">                            <span class="built_in">queue</span>.push(newword);</span><br><span class="line">                            del.insert(newword);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;      </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;graph, <span class="built_in">string</span>&amp; beginWord, <span class="built_in">string</span>&amp; endWord)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beginWord == endWord)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(current); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : graph[beginWord])</span><br><span class="line">        &#123;</span><br><span class="line">            current.push_back(str);</span><br><span class="line">            dfs(graph,str, endWord);</span><br><span class="line">            current.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></h2><p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。<br>示例:<br>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">int</span>  maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap[num] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left = hashmap[num<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> right  = hashmap[num+<span class="number">1</span>];</span><br><span class="line">                hashmap[num] = left + right + <span class="number">1</span>;</span><br><span class="line">                hashmap[num-left] = left + right + <span class="number">1</span>;</span><br><span class="line">                hashmap[num+right] = left + right + <span class="number">1</span>;</span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, left + right + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129.求根到叶子节点数字之和"></a>129.<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">求根到叶子节点数字之和</a></h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>计算从根到叶子节点生成的所有数字之和。<br>说明: 叶子节点是指没有子节点的节点。<br>输入: [1,2,3]<br><img src= "/img/loading.gif" data-lazy-src="/img/leetcode129.png"><br>输出:25</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> current)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="number">10</span>*current + root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root -&gt; left,<span class="number">10</span>*current +  root-&gt;val);</span><br><span class="line">        dfs(root -&gt; right,<span class="number">10</span>*current +  root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">## <span class="number">130.</span>[被围绕的区域](https:<span class="comment">//leetcode-cn.com/problems/surrounded-regions/)</span></span><br><span class="line"></span><br><span class="line">给定一个二维的矩阵，包含 <span class="string">&#x27;X&#x27;</span> 和 <span class="string">&#x27;O&#x27;</span>（字母 O）。</span><br><span class="line">找到所有被 <span class="string">&#x27;X&#x27;</span> 围绕的区域，并将这些区域里所有的 <span class="string">&#x27;O&#x27;</span> 用 <span class="string">&#x27;X&#x27;</span> 填充。</span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line">被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="string">&#x27;O&#x27;</span> 都不会被填充为 <span class="string">&#x27;X&#x27;</span>。 任何不在边界上，或不与边界上的 <span class="string">&#x27;O&#x27;</span> 相连的 <span class="string">&#x27;O&#x27;</span> 最终都会被填充为 <span class="string">&#x27;X&#x27;</span>。</span><br><span class="line">如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br><span class="line"></span><br><span class="line">从边界出发，将与边界O连通的标记为B,最后遍历这个board,将O变为X,将B变为O.</span><br><span class="line">###dfs</span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">void</span> solve(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span> || x == m<span class="number">-1</span> || y == <span class="number">0</span> || y == n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                        dfs(board,x,y);&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                    board[x][y] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> dfs(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span> || x == board.<span class="built_in">size</span>() || y == <span class="number">-1</span> || y == board[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;X&#x27;</span> || board[x][y] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; dir : direction)</span><br><span class="line">            dfs(board, x+dir[<span class="number">0</span>], y+dir[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进版，提前判断，减少进入函数栈次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span> || x == m<span class="number">-1</span> || y == <span class="number">0</span> || y == n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                        dfs(board,x,y);&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; x++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    board[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                    board[x][y] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; dir : direction)</span><br><span class="line">        <span class="keyword">if</span>( x+dir[<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp;  x+dir[<span class="number">0</span>] &lt;= board.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; y+dir[<span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp; y+dir[<span class="number">1</span>] &lt;= board[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; board[x+dir[<span class="number">0</span>]][y+dir[<span class="number">1</span>]] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board, x+dir[<span class="number">0</span>], y+dir[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1529-灯泡开关-IV"><a href="#1529-灯泡开关-IV" class="headerlink" title="1529.灯泡开关 IV"></a>1529.<a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">灯泡开关 IV</a></h2><p>房间中有n个灯泡，编号从0到n-1，自左向右排成一行。最开始的时候，所有的灯泡都是关着的。<br>请你设法使得灯泡的开关状态和target描述的状态一致，其中target[i]等于1第 个灯泡是开着的，等于0意味着第i个灯是关着的。<br>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：<br>选择当前配置下的任意一个灯泡下标为i）<br>翻转下标从i到n-1的每个灯泡<br>翻转时，如果灯泡的状态为0就变为1，为1就变为 0 。<br>返回达成target描述的状态所需的最少翻转次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;0&quot;</span> + target;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != str[i<span class="number">-1</span>])</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需要看target的每位与前一位是否相同,不相同则一定该位发生翻转.</p><h2 id="1530-好叶子节点对的数量"><a href="#1530-好叶子节点对的数量" class="headerlink" title="1530.好叶子节点对的数量"></a>1530.<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a></h2><p>给你二叉树的根节点root和一个整数 distance。<br>如果二叉树中两个叶节点之间的 最短路径长度小于或者等于distance，那它们就可以构成一组好叶子节点对。<br>返回树中好叶子节点对的数量。<br><img src= "/img/loading.gif" data-lazy-src="/img/leetcode1530.jpg"><br>输入：root = [1,2,3,4,5,6,7], distance = 3<br>输出：2<br>解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        dfs(root, distance);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; distance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt;left == <span class="literal">nullptr</span> &amp;&amp; root -&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_leaf = dfs(root-&gt;left, distance);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_leaf = dfs(root-&gt;right, distance);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l :left_leaf)</span><br><span class="line">            <span class="keyword">if</span>(++l &lt; distance) ret.push_back(l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> r :right_leaf)</span><br><span class="line">            <span class="keyword">if</span>(++r &lt; distance) ret.push_back(r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l : left_leaf)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r : right_leaf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( l + r + <span class="number">2</span> &lt;= distance)</span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历,找到叶子节点,统计当前左右叶子结点是否能够满足要求,并且将当前距离+1返回其父结点.</p><h2 id="1534-统计三元组"><a href="#1534-统计三元组" class="headerlink" title="1534.统计三元组"></a>1534.<a href="https://leetcode-cn.com/problems/count-good-triplets/">统计三元组</a></h2><p>给你一个整数数组 arr，以及 a、b 、c 三个整数。请你其中好三元组的数量。<br>如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个好三元组<br>0 &lt;= i &lt; j &lt; k &lt; arr.length<br>|arr[i] - arr[j]| &lt;= a<br>|arr[j] - arr[k]| &lt;= b<br>|arr[i] - arr[k]| &lt;= c<br>其中|x|表示x的绝对值。<br>返回好三元组的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n<span class="number">-1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i] - arr[j]) &lt;= a)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="built_in">abs</span>(arr[i] - arr[k]) &lt;= c)</span><br><span class="line">                            res++;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">```https:<span class="comment">//leetcode-cn.com/problems/bulb-switcher-iv/</span></span><br><span class="line">## <span class="number">1535.</span>[找出数组游戏的赢家](https:<span class="comment">//leetcode-cn.com/problems/find-the-winner-of-an-array-game/)</span></span><br><span class="line">给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。</span><br><span class="line">每回合游戏都在数组的前两个元素（即arr[<span class="number">0</span>]和arr[<span class="number">1</span>]）之间进行。比较 arr[<span class="number">0</span>] 与 arr[<span class="number">1</span>] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <span class="number">0</span> ，较小的整数移至数组的末尾。当一个整数赢得k个连续回合时，游戏结束，该整数就是比赛的 赢家 。</span><br><span class="line">返回赢得比赛的整数。</span><br><span class="line">题目数据保证游戏存在赢家。</span><br><span class="line">![](/img/leetcode1535.png)</span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> getWinner(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        k = k &gt; arr.<span class="built_in">size</span>()<span class="number">-1</span>? arr.<span class="built_in">size</span>()<span class="number">-1</span> : k;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>,second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(second &gt; arr.<span class="built_in">size</span>()<span class="number">-1</span>) second = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[first] &gt; arr[second])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                second++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                first = second;</span><br><span class="line">                second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1536-排布二进制网格的最少交换次数"><a href="#1536-排布二进制网格的最少交换次数" class="headerlink" title="1536.排布二进制网格的最少交换次数"></a>1536.<a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">排布二进制网格的最少交换次数</a></h2><p>给你一个n x n的二进制网格grid，每一次操作中，你可以选择网格的相邻两行进行交换。<br>一个符合要求的网格需要满足主对角线以上的格子全部都是0。<br>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回-1 。<br>主对角线指的是从(1, 1)到(n, n)的这些格子。<br><img src= "/img/loading.gif" data-lazy-src="/img/leetcode1536.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    row[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] &lt; n-i<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span>(; j &lt; n; j++)</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="keyword">if</span>(row[j] &gt;= n-i <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">step</span> += j-i;</span><br><span class="line">                        <span class="keyword">for</span>(;j&gt;i;j--)</span><br><span class="line">                            swap(row[j],row[j<span class="number">-1</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>读取每一行后缀0的个数,第n行(从0开始),每一行至少要有你n-i-1(i表示当前行)个后缀0.当该行不满足条件时,采用贪心算法,遇到最近满足条件,则依次交换到第i行.</p><h2 id="1537-最大得分"><a href="#1537-最大得分" class="headerlink" title="1537.最大得分"></a>1537.<a href="https://leetcode-cn.com/problems/get-the-maximum-score/">最大得分</a></h2><p>你有两个 有序 且数组内元素互不相同的数组 nums1 和 nums2 。<br>一条 合法路径 定义如下：<br>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。<br>从左到右遍历当前数组。<br>如果你遇到了 nums1 和 nums2 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。<br>得分定义为合法路径中不同数字的和。<br>请你返回所有可能合法路径中的最大得分。<br>由于答案可能很大，请你将它对 10^9 + 7 取余后返回<br><img src= "/img/loading.gif" data-lazy-src="/img/leetcode1537.png"><br>输入：nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]<br>输出：30<br>解释：合法路径包括：<br>[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）<br>[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）<br>最大得分为上图中的绿色路径 [2,4,6,8,10] 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>, sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sum1 += nums1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sum2 += nums2[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] == nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="built_in">max</span>(sum1 + nums1[i], sum2 + nums2[j]);</span><br><span class="line">                sum1 = <span class="number">0</span>;sum2 = <span class="number">0</span>;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1 += nums1[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum2 += nums2[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += <span class="built_in">max</span>(sum1, sum2);</span><br><span class="line">        <span class="keyword">return</span> sum%(<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/img/leetcode1537tujie.png"><br>由于nums1,nums2相同的数字,可以多种选择.以相同的数字为断点,将两个数组分成多块.分别计算每块的和,比较得到最大值.<br>由上图将两个数组分成三块,计算每块每条路径的值.获得每块路径的最大值相加得到最大值就为结果.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
