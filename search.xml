<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode</title>
      <link href="/2020/08/09/hello-world/"/>
      <url>/2020/08/09/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). --><h1 id="Leetcode算法解答"><a href="#Leetcode算法解答" class="headerlink" title="Leetcode算法解答."></a>Leetcode算法解答.</h1><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114.<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/"> 二叉树展开为链表</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(root == nullptr) return;</span></span><br><span class="line">        <span class="keyword">int</span> white = <span class="number">0</span>, gray = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,TreeNode*&gt;&gt;<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(white,root));</span><br><span class="line">        TreeNode* dummyroot = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> color = <span class="built_in">stack</span>.top().first;</span><br><span class="line">            TreeNode* node = <span class="built_in">stack</span>.top().second;</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(color == white)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(white,node-&gt;right));</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(white,node-&gt;left));</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">make_pair</span>(gray,node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dummyroot-&gt;right = node;</span><br><span class="line">                dummyroot-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                dummyroot = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = dummyroot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采用先序遍历,创建新的结点依次链接先序遍历得到的值.</p><h2 id="1529-灯泡开关-IV"><a href="#1529-灯泡开关-IV" class="headerlink" title="1529.灯泡开关 IV"></a>1529.<a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">灯泡开关 IV</a></h2><p>房间中有n个灯泡，编号从0到n-1，自左向右排成一行。最开始的时候，所有的灯泡都是关着的。<br>请你设法使得灯泡的开关状态和target描述的状态一致，其中target[i]等于1第 个灯泡是开着的，等于0意味着第i个灯是关着的。<br>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：<br>选择当前配置下的任意一个灯泡下标为i）<br>翻转下标从i到n-1的每个灯泡<br>翻转时，如果灯泡的状态为0就变为1，为1就变为 0 。<br>返回达成target描述的状态所需的最少翻转次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;0&quot;</span> + target;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != str[i<span class="number">-1</span>])</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需要看target的每位与前一位是否相同,不相同则一定该位发生翻转.</p><h2 id="1530-好叶子节点对的数量"><a href="#1530-好叶子节点对的数量" class="headerlink" title="1530.好叶子节点对的数量"></a>1530.<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a></h2><p>给你二叉树的根节点root和一个整数 distance。<br>如果二叉树中两个叶节点之间的 最短路径长度小于或者等于distance，那它们就可以构成一组好叶子节点对。<br>返回树中好叶子节点对的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        dfs(root, distance);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; distance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt;left == <span class="literal">nullptr</span> &amp;&amp; root -&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_leaf = dfs(root-&gt;left, distance);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_leaf = dfs(root-&gt;right, distance);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l :left_leaf)</span><br><span class="line">            <span class="keyword">if</span>(++l &lt; distance) ret.push_back(l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> r :right_leaf)</span><br><span class="line">            <span class="keyword">if</span>(++r &lt; distance) ret.push_back(r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l : left_leaf)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r : right_leaf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( l + r + <span class="number">2</span> &lt;= distance)</span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历,找到叶子节点,统计当前左右叶子结点是否能够满足要求,并且将当前距离+1返回其父结点.</p><h2 id="1534-统计三元组"><a href="#1534-统计三元组" class="headerlink" title="1534.统计三元组"></a>1534.<a href="https://leetcode-cn.com/problems/count-good-triplets/">统计三元组</a></h2><p>给你一个整数数组 arr，以及 a、b 、c 三个整数。请你其中好三元组的数量。<br>如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个好三元组<br>0 &lt;= i &lt; j &lt; k &lt; arr.length<br>|arr[i] - arr[j]| &lt;= a<br>|arr[j] - arr[k]| &lt;= b<br>|arr[i] - arr[k]| &lt;= c<br>其中|x|表示x的绝对值。<br>返回好三元组的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n<span class="number">-1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i] - arr[j]) &lt;= a)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="built_in">abs</span>(arr[i] - arr[k]) &lt;= c)</span><br><span class="line">                            res++;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
